# [934. Shortest Bridge][enTitle]

**Medium**

In a given 2D binary array  *A* , there are two islands. (An island is a 4-directionally connected group of  *1* s not connected to any other 1s.)

Now, we may change  *0* s to  *1* s so as to connect the two islands together to form 1 island.

Return the smallest number of  *0* s that must be flipped. (It is guaranteed that the answer is at least 1.)



**Example 1:** 

```
Input: A = [[0,1],[1,0]]
Output: 1

```

**Example 2:** 

```
Input: A = [[0,1,0],[0,0,0],[0,0,1]]
Output: 2

```

**Example 3:** 

```
Input: A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
Output: 1

```



**Constraints:** 

-  *2 <= A.length == A[0].length <= 100*  
-  *A[i][j] == 0*  or  *A[i][j] == 1* 


# [934. 最短的桥][cnTitle]

**中等**

在给定的二维二进制数组  *A*  中，存在两座岛。（岛是由四面相连的  *1*  形成的一个最大组。）

现在，我们可以将  *0*  变为  *1* ，以使两座岛连接起来，变成一座岛。

返回必须翻转的  *0*  的最小数目。（可以保证答案至少是 1。）



**示例 1：** 

```
输入：[[0,1],[1,0]]
输出：1

```

**示例 2：** 

```
输入：[[0,1,0],[0,0,0],[0,0,1]]
输出：2

```

**示例 3：** 

```
输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
输出：1
```



**提示：** 

1.  *1 <= A.length = A[0].length <= 100*  
2.  *A[i][j] == 0*  或  *A[i][j] == 1* 






# 算法思路

# 测试用例
```
934. Shortest Bridge 934. 最短的桥 Medium
```

[enTitle]: https://leetcode.com/problems/shortest-bridge/
[cnTitle]: https://leetcode-cn.com/problems/shortest-bridge/
